<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ディープラーニングシステム - 統合AI実験プラットフォーム</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #2563eb;
            --secondary-color: #7c3aed;
            --accent-color: #059669;
            --danger-color: #dc2626;
            --warning-color: #d97706;
            --bg-color: #0f172a;
            --surface-color: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border-color: #334155;
            --gradient: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-color);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: auto;
        }

        .header {
            background: var(--gradient);
            padding: 1rem 2rem;
            box-shadow: 0 4px 20px rgba(37, 99, 235, 0.3);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .main-container {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            gap: 1rem;
            padding: 1rem;
            max-width: 1800px;
            margin: 0 auto;
            min-height: calc(100vh - 100px);
        }

        .panel {
            background: var(--surface-color);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .panel h2 {
            color: var(--text-primary);
            margin-bottom: 1rem;
            font-size: 1.2rem;
            font-weight: 600;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }

        /* モデル構築エリア */
        .model-builder {
            overflow-y: auto;
            max-height: calc(100vh - 150px);
        }

        .layer-palette {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .layer-button {
            padding: 0.75rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .layer-button:hover {
            background: #1d4ed8;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .network-visual {
            min-height: 300px;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            position: relative;
            background: rgba(37, 99, 235, 0.05);
        }

        .layer-node {
            background: var(--gradient);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            margin: 0.5rem 0;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .layer-node:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(37, 99, 235, 0.4);
        }

        .layer-node::after {
            content: '↓';
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--text-secondary);
        }

        .layer-node:last-child::after {
            display: none;
        }

        /* メインワークスペース */
        .workspace {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .controls-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .control-group {
            background: rgba(37, 99, 235, 0.1);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .control-group label {
            display: block;
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .control-input {
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .dataset-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .dataset-button {
            padding: 0.75rem;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .dataset-button:hover, .dataset-button.active {
            background: #047857;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(5, 150, 105, 0.3);
        }

        .action-buttons {
            display: flex;
            gap: 1rem;
            margin: 1rem 0;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-secondary {
            background: var(--secondary-color);
            color: white;
        }

        .btn-success {
            background: var(--accent-color);
            color: white;
        }

        .btn-danger {
            background: var(--danger-color);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* 可視化エリア */
        .visualization {
            overflow-y: auto;
            max-height: calc(100vh - 150px);
        }

        .chart-container {
            position: relative;
            height: 250px;
            margin: 1rem 0;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 1rem;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
        }

        .metric-card {
            background: rgba(37, 99, 235, 0.1);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent-color);
            display: block;
        }

        .metric-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--gradient);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .status-idle {
            background: var(--text-secondary);
        }

        .status-training {
            background: var(--warning-color);
            animation: pulse 1.5s infinite;
        }

        .status-complete {
            background: var(--accent-color);
        }

        .status-error {
            background: var(--danger-color);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .prediction-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .prediction-item {
            background: rgba(0,0,0,0.3);
            padding: 0.5rem;
            border-radius: 6px;
            text-align: center;
            font-size: 0.8rem;
            border: 1px solid var(--border-color);
        }

        .prediction-value {
            font-weight: 700;
            color: var(--accent-color);
        }

        .experiment-history {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 1rem;
        }

        .experiment-item {
            background: rgba(0,0,0,0.2);
            padding: 0.75rem;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            border-left: 3px solid var(--primary-color);
        }

        .experiment-meta {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        /* レスポンシブ対応 */
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
            }
            
            .panel {
                max-height: none;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 0.5rem;
                gap: 0.5rem;
            }
            
            .header {
                padding: 0.75rem 1rem;
            }
            
            .header h1 {
                font-size: 1.4rem;
            }
            
            .controls-row {
                grid-template-columns: 1fr;
            }
            
            .action-buttons {
                flex-direction: column;
            }
            
            .layer-palette {
                grid-template-columns: 1fr;
            }
        }

        /* アニメーション */
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .training-pulse {
            animation: trainingPulse 2s infinite;
        }

        @keyframes trainingPulse {
            0%, 100% { 
                box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.7);
            }
            70% { 
                box-shadow: 0 0 0 10px rgba(37, 99, 235, 0);
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🧠 ディープラーニングシステム - 統合AI実験プラットフォーム</h1>
    </div>

    <div class="main-container">
        <!-- モデル構築パネル -->
        <div class="panel model-builder">
            <h2>🏗️ モデル構築</h2>
            
            <div class="layer-palette">
                <button class="layer-button" onclick="addLayer('dense')">Dense</button>
                <button class="layer-button" onclick="addLayer('conv2d')">Conv2D</button>
                <button class="layer-button" onclick="addLayer('maxpool')">MaxPool</button>
                <button class="layer-button" onclick="addLayer('dropout')">Dropout</button>
                <button class="layer-button" onclick="addLayer('flatten')">Flatten</button>
                <button class="layer-button" onclick="addLayer('activation')">Activation</button>
            </div>

            <div class="network-visual" id="networkVisual">
                <div style="text-align: center; color: var(--text-secondary); margin-top: 50px;">
                    レイヤーをクリックしてネットワークを構築してください
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-secondary" onclick="clearNetwork()">クリア</button>
                <button class="btn btn-success" onclick="buildModel()">モデル構築</button>
            </div>

            <div class="control-group">
                <label>モデル構成</label>
                <div id="modelSummary" style="font-size: 0.8rem; color: var(--text-secondary);">
                    まだモデルが構築されていません
                </div>
            </div>
        </div>

        <!-- メインワークスペース -->
        <div class="panel workspace">
            <h2>🎯 学習制御 & データセット</h2>
            
            <div class="dataset-selector">
                <button class="dataset-button active" onclick="selectDataset('mnist')">MNIST</button>
                <button class="dataset-button" onclick="selectDataset('xor')">XOR</button>
                <button class="dataset-button" onclick="selectDataset('linear')">線形回帰</button>
                <button class="dataset-button" onclick="selectDataset('classification')">2D分類</button>
            </div>

            <div class="controls-row">
                <div class="control-group">
                    <label>学習率</label>
                    <input type="range" id="learningRate" class="control-input" min="0.0001" max="0.1" step="0.0001" value="0.001">
                    <span id="learningRateValue">0.001</span>
                </div>
                
                <div class="control-group">
                    <label>バッチサイズ</label>
                    <input type="range" id="batchSize" class="control-input" min="16" max="128" step="16" value="32">
                    <span id="batchSizeValue">32</span>
                </div>
                
                <div class="control-group">
                    <label>エポック数</label>
                    <input type="range" id="epochs" class="control-input" min="1" max="100" step="1" value="10">
                    <span id="epochsValue">10</span>
                </div>
                
                <div class="control-group">
                    <label>オプティマイザー</label>
                    <select id="optimizer" class="control-input">
                        <option value="adam">Adam</option>
                        <option value="sgd">SGD</option>
                        <option value="rmsprop">RMSprop</option>
                    </select>
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" id="trainBtn" onclick="startTraining()">🚀 学習開始</button>
                <button class="btn btn-danger" id="stopBtn" onclick="stopTraining()" disabled>⏹️ 停止</button>
                <button class="btn btn-secondary" onclick="resetModel()">🔄 リセット</button>
                <button class="btn btn-success" onclick="predictSample()">🔮 予測実行</button>
            </div>

            <div class="control-group">
                <label>学習進捗</label>
                <div style="display: flex; align-items: center; margin: 0.5rem 0;">
                    <span class="status-indicator status-idle" id="statusIndicator"></span>
                    <span id="statusText">待機中</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
                <div style="font-size: 0.8rem; color: var(--text-secondary);" id="progressText">
                    エポック: 0/0 | 損失: - | 精度: -
                </div>
            </div>

            <div class="chart-container">
                <canvas id="lossChart"></canvas>
            </div>
        </div>

        <!-- 可視化・結果パネル -->
        <div class="panel visualization">
            <h2>📊 可視化 & 結果</h2>
            
            <div class="metrics-grid">
                <div class="metric-card">
                    <span class="metric-value" id="accuracyValue">-</span>
                    <span class="metric-label">精度</span>
                </div>
                <div class="metric-card">
                    <span class="metric-value" id="lossValue">-</span>
                    <span class="metric-label">損失</span>
                </div>
                <div class="metric-card">
                    <span class="metric-value" id="epochValue">-</span>
                    <span class="metric-label">エポック</span>
                </div>
                <div class="metric-card">
                    <span class="metric-value" id="timeValue">-</span>
                    <span class="metric-label">時間(秒)</span>
                </div>
            </div>

            <div class="control-group">
                <label>予測結果</label>
                <div class="prediction-grid" id="predictionGrid">
                    <div class="prediction-item">
                        <div class="prediction-value">-</div>
                        <div>待機中</div>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <canvas id="accuracyChart"></canvas>
            </div>

            <div class="control-group">
                <label>ネットワーク可視化</label>
                <div id="networkViz" style="min-height: 150px; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 1rem; margin-top: 0.5rem;">
                    <div style="text-align: center; color: var(--text-secondary); margin-top: 50px;">
                        モデル構築後に表示されます
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label>実験履歴</label>
                <div class="experiment-history" id="experimentHistory">
                    <div style="text-align: center; color: var(--text-secondary); padding: 2rem;">
                        実験履歴はまだありません
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // グローバル変数
        let model = null;
        let dataset = null;
        let isTraining = false;
        let trainingHistory = [];
        let lossChart = null;
        let accuracyChart = null;
        let currentDataset = 'mnist';
        let networkLayers = [];
        let experiments = [];

        // TensorFlow.js 初期化確認
        console.log('TensorFlow.js version:', tf.version.tfjs);

        // 初期化
        document.addEventListener('DOMContentLoaded', function() {
            initializeCharts();
            setupEventListeners();
            loadDataset('mnist');
            updateStatus('待機中', 'idle');
        });

        // イベントリスナー設定
        function setupEventListeners() {
            document.getElementById('learningRate').addEventListener('input', function(e) {
                document.getElementById('learningRateValue').textContent = e.target.value;
            });
            
            document.getElementById('batchSize').addEventListener('input', function(e) {
                document.getElementById('batchSizeValue').textContent = e.target.value;
            });
            
            document.getElementById('epochs').addEventListener('input', function(e) {
                document.getElementById('epochsValue').textContent = e.target.value;
            });
        }

        // チャート初期化
        function initializeCharts() {
            const ctx1 = document.getElementById('lossChart').getContext('2d');
            const ctx2 = document.getElementById('accuracyChart').getContext('2d');

            lossChart = new Chart(ctx1, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '学習損失',
                        data: [],
                        borderColor: '#dc2626',
                        backgroundColor: 'rgba(220, 38, 38, 0.1)',
                        tension: 0.3
                    }, {
                        label: '検証損失',
                        data: [],
                        borderColor: '#7c3aed',
                        backgroundColor: 'rgba(124, 58, 237, 0.1)',
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#f1f5f9' }
                        }
                    },
                    scales: {
                        x: { 
                            ticks: { color: '#94a3b8' },
                            grid: { color: '#334155' }
                        },
                        y: { 
                            ticks: { color: '#94a3b8' },
                            grid: { color: '#334155' }
                        }
                    }
                }
            });

            accuracyChart = new Chart(ctx2, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '学習精度',
                        data: [],
                        borderColor: '#059669',
                        backgroundColor: 'rgba(5, 150, 105, 0.1)',
                        tension: 0.3
                    }, {
                        label: '検証精度',
                        data: [],
                        borderColor: '#2563eb',
                        backgroundColor: 'rgba(37, 99, 235, 0.1)',
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#f1f5f9' }
                        }
                    },
                    scales: {
                        x: { 
                            ticks: { color: '#94a3b8' },
                            grid: { color: '#334155' }
                        },
                        y: { 
                            ticks: { color: '#94a3b8' },
                            grid: { color: '#334155' },
                            min: 0,
                            max: 1
                        }
                    }
                }
            });
        }

        // データセット選択
        async function selectDataset(type) {
            currentDataset = type;
            
            // ボタンのアクティブ状態更新
            document.querySelectorAll('.dataset-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            await loadDataset(type);
            updateStatus(`${type.toUpperCase()}データセット読み込み完了`, 'complete');
        }

        // データセット読み込み
        async function loadDataset(type) {
            try {
                switch(type) {
                    case 'mnist':
                        dataset = await loadMNISTData();
                        break;
                    case 'xor':
                        dataset = generateXORData();
                        break;
                    case 'linear':
                        dataset = generateLinearData();
                        break;
                    case 'classification':
                        dataset = generate2DClassificationData();
                        break;
                }
                
                console.log(`${type} データセット読み込み完了:`, dataset);
            } catch (error) {
                console.error('データセット読み込みエラー:', error);
                updateStatus('データセット読み込みエラー', 'error');
            }
        }

        // MNIST データ（簡易版）
        async function loadMNISTData() {
            const numSamples = 1000;
            const imageSize = 28 * 28;
            
            // 簡易的なMNISTデータ生成（実際のMNISTデータの代用）
            const xTrain = tf.randomNormal([numSamples, imageSize]);
            const yTrain = tf.randomUniform([numSamples], 0, 10, 'int32');
            const yTrainOneHot = tf.oneHot(yTrain, 10);
            
            return {
                xTrain: xTrain,
                yTrain: yTrainOneHot,
                xTest: tf.randomNormal([200, imageSize]),
                yTest: tf.oneHot(tf.randomUniform([200], 0, 10, 'int32'), 10),
                inputShape: [imageSize],
                outputShape: 10,
                type: 'classification'
            };
        }

        // XOR データ
        function generateXORData() {
            const data = [
                [0, 0, 0],
                [0, 1, 1],
                [1, 0, 1],
                [1, 1, 0]
            ];
            
            const numSamples = 1000;
            const samples = [];
            const labels = [];
            
            for (let i = 0; i < numSamples; i++) {
                const sample = data[Math.floor(Math.random() * data.length)];
                samples.push([sample[0], sample[1]]);
                labels.push([sample[2]]);
            }
            
            return {
                xTrain: tf.tensor2d(samples),
                yTrain: tf.tensor2d(labels),
                xTest: tf.tensor2d(samples.slice(0, 200)),
                yTest: tf.tensor2d(labels.slice(0, 200)),
                inputShape: [2],
                outputShape: 1,
                type: 'binary'
            };
        }

        // 線形回帰データ
        function generateLinearData() {
            const numSamples = 1000;
            const x = tf.randomNormal([numSamples, 1]);
            const y = x.mul(2).add(1).add(tf.randomNormal([numSamples, 1], 0, 0.1));
            
            return {
                xTrain: x,
                yTrain: y,
                xTest: tf.randomNormal([200, 1]),
                yTest: tf.randomNormal([200, 1]),
                inputShape: [1],
                outputShape: 1,
                type: 'regression'
            };
        }

        // 2D分類データ
        function generate2DClassificationData() {
            const numSamples = 1000;
            const x = tf.randomNormal([numSamples, 2]);
            const y = x.sum(axis=1).greater(0).cast('int32');
            const yOneHot = tf.oneHot(y, 2);
            
            return {
                xTrain: x,
                yTrain: yOneHot,
                xTest: tf.randomNormal([200, 2]),
                yTest: tf.oneHot(tf.randomNormal([200, 2]).sum(axis=1).greater(0).cast('int32'), 2),
                inputShape: [2],
                outputShape: 2,
                type: 'classification'
            };
        }

        // レイヤー追加
        function addLayer(layerType) {
            const layer = {
                type: layerType,
                id: Date.now(),
                params: getDefaultLayerParams(layerType)
            };
            
            networkLayers.push(layer);
            updateNetworkVisual();
        }

        // デフォルトレイヤーパラメータ
        function getDefaultLayerParams(layerType) {
            switch(layerType) {
                case 'dense':
                    return { units: 64, activation: 'relu' };
                case 'conv2d':
                    return { filters: 32, kernelSize: 3, activation: 'relu' };
                case 'maxpool':
                    return { poolSize: 2 };
                case 'dropout':
                    return { rate: 0.5 };
                case 'flatten':
                    return {};
                case 'activation':
                    return { activation: 'relu' };
                default:
                    return {};
            }
        }

        // ネットワーク可視化更新
        function updateNetworkVisual() {
            const visual = document.getElementById('networkVisual');
            
            if (networkLayers.length === 0) {
                visual.innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); margin-top: 50px;">
                        レイヤーをクリックしてネットワークを構築してください
                    </div>
                `;
                return;
            }
            
            let html = '';
            networkLayers.forEach((layer, index) => {
                const params = Object.entries(layer.params)
                    .map(([key, value]) => `${key}: ${value}`)
                    .join(', ');
                
                html += `
                    <div class="layer-node" onclick="removeLayer(${index})">
                        <strong>${layer.type.toUpperCase()}</strong>
                        ${params ? `<br><small>${params}</small>` : ''}
                    </div>
                `;
            });
            
            visual.innerHTML = html;
        }

        // レイヤー削除
        function removeLayer(index) {
            networkLayers.splice(index, 1);
            updateNetworkVisual();
        }

        // ネットワーククリア
        function clearNetwork() {
            networkLayers = [];
            updateNetworkVisual();
            updateModelSummary('まだモデルが構築されていません');
        }

        // モデル構築
        async function buildModel() {
            try {
                if (networkLayers.length === 0) {
                    alert('レイヤーを追加してからモデルを構築してください');
                    return;
                }

                model = tf.sequential();
                
                // 入力レイヤー
                const inputShape = dataset ? dataset.inputShape : [784];
                let isFirstLayer = true;
                
                for (const layer of networkLayers) {
                    let tfLayer;
                    
                    switch(layer.type) {
                        case 'dense':
                            tfLayer = tf.layers.dense({
                                units: layer.params.units,
                                activation: layer.params.activation,
                                inputShape: isFirstLayer ? inputShape : undefined
                            });
                            break;
                        case 'conv2d':
                            tfLayer = tf.layers.conv2d({
                                filters: layer.params.filters,
                                kernelSize: layer.params.kernelSize,
                                activation: layer.params.activation,
                                inputShape: isFirstLayer ? [28, 28, 1] : undefined
                            });
                            break;
                        case 'maxpool':
                            tfLayer = tf.layers.maxPooling2d({
                                poolSize: layer.params.poolSize
                            });
                            break;
                        case 'dropout':
                            tfLayer = tf.layers.dropout({
                                rate: layer.params.rate
                            });
                            break;
                        case 'flatten':
                            tfLayer = tf.layers.flatten();
                            break;
                        case 'activation':
                            tfLayer = tf.layers.activation({
                                activation: layer.params.activation
                            });
                            break;
                    }
                    
                    if (tfLayer) {
                        model.add(tfLayer);
                        isFirstLayer = false;
                    }
                }
                
                // 出力レイヤー自動追加
                if (dataset) {
                    const outputActivation = dataset.type === 'binary' ? 'sigmoid' : 
                                           dataset.type === 'classification' ? 'softmax' : 'linear';
                    model.add(tf.layers.dense({
                        units: dataset.outputShape,
                        activation: outputActivation
                    }));
                }
                
                // モデルコンパイル
                const optimizer = document.getElementById('optimizer').value;
                const learningRate = parseFloat(document.getElementById('learningRate').value);
                
                model.compile({
                    optimizer: tf.train.adam(learningRate),
                    loss: dataset && dataset.type === 'binary' ? 'binaryCrossentropy' :
                          dataset && dataset.type === 'classification' ? 'categoricalCrossentropy' : 'meanSquaredError',
                    metrics: ['accuracy']
                });
                
                updateModelSummary(`${model.layers.length}層のモデルが構築されました`);
                updateNetworkVisualization();
                updateStatus('モデル構築完了', 'complete');
                
                console.log('モデル構築完了:', model);
                
            } catch (error) {
                console.error('モデル構築エラー:', error);
                updateStatus('モデル構築エラー', 'error');
                alert('モデル構築中にエラーが発生しました: ' + error.message);
            }
        }

        // モデル要約更新
        function updateModelSummary(text) {
            document.getElementById('modelSummary').textContent = text;
        }

        // ネットワーク可視化更新
        function updateNetworkVisualization() {
            const viz = document.getElementById('networkViz');
            
            if (!model) {
                viz.innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); margin-top: 50px;">
                        モデル構築後に表示されます
                    </div>
                `;
                return;
            }
            
            let html = '<div style="font-size: 0.8rem;">';
            model.layers.forEach((layer, index) => {
                const outputShape = layer.outputShape ? 
                    layer.outputShape.slice(1).join(' × ') : 'unknown';
                html += `
                    <div style="padding: 0.5rem; background: rgba(37, 99, 235, 0.1); margin: 0.25rem 0; border-radius: 4px;">
                        <strong>${layer.getClassName()}</strong><br>
                        <small>出力: ${outputShape}</small>
                    </div>
                `;
            });
            html += '</div>';
            
            viz.innerHTML = html;
        }

        // 学習開始
        async function startTraining() {
            if (!model || !dataset) {
                alert('モデルとデータセットを準備してから学習を開始してください');
                return;
            }
            
            isTraining = true;
            updateTrainingControls(true);
            updateStatus('学習中...', 'training');
            
            const epochs = parseInt(document.getElementById('epochs').value);
            const batchSize = parseInt(document.getElementById('batchSize').value);
            
            const startTime = Date.now();
            trainingHistory = [];
            
            try {
                const history = await model.fit(dataset.xTrain, dataset.yTrain, {
                    epochs: epochs,
                    batchSize: batchSize,
                    validationSplit: 0.2,
                    callbacks: {
                        onEpochEnd: async (epoch, logs) => {
                            if (!isTraining) return;
                            
                            const progress = ((epoch + 1) / epochs) * 100;
                            updateProgress(progress, epoch + 1, epochs, logs.loss, logs.acc || logs.accuracy);
                            updateCharts(epoch + 1, logs);
                            
                            trainingHistory.push({
                                epoch: epoch + 1,
                                loss: logs.loss,
                                accuracy: logs.acc || logs.accuracy,
                                valLoss: logs.val_loss,
                                valAccuracy: logs.val_acc || logs.val_accuracy
                            });
                            
                            // UI更新のため少し待機
                            await tf.nextFrame();
                        }
                    }
                });
                
                if (isTraining) {
                    const endTime = Date.now();
                    const duration = (endTime - startTime) / 1000;
                    
                    updateStatus('学習完了', 'complete');
                    updateMetrics(duration);
                    
                    // 実験履歴に追加
                    addExperiment({
                        timestamp: new Date(),
                        dataset: currentDataset,
                        epochs: epochs,
                        batchSize: batchSize,
                        finalLoss: trainingHistory[trainingHistory.length - 1]?.loss || 0,
                        finalAccuracy: trainingHistory[trainingHistory.length - 1]?.accuracy || 0,
                        duration: duration
                    });
                }
                
            } catch (error) {
                console.error('学習エラー:', error);
                updateStatus('学習エラー', 'error');
                alert('学習中にエラーが発生しました: ' + error.message);
            } finally {
                isTraining = false;
                updateTrainingControls(false);
            }
        }

        // 学習停止
        function stopTraining() {
            isTraining = false;
            updateStatus('学習停止', 'idle');
            updateTrainingControls(false);
        }

        // 進捗更新
        function updateProgress(progress, epoch, totalEpochs, loss, accuracy) {
            document.getElementById('progressFill').style.width = `${progress}%`;
            document.getElementById('progressText').textContent = 
                `エポック: ${epoch}/${totalEpochs} | 損失: ${loss.toFixed(4)} | 精度: ${(accuracy * 100).toFixed(1)}%`;
        }

        // チャート更新
        function updateCharts(epoch, logs) {
            // 損失チャート
            lossChart.data.labels.push(epoch);
            lossChart.data.datasets[0].data.push(logs.loss);
            lossChart.data.datasets[1].data.push(logs.val_loss || logs.loss);
            lossChart.update('none');
            
            // 精度チャート
            accuracyChart.data.labels.push(epoch);
            accuracyChart.data.datasets[0].data.push(logs.acc || logs.accuracy);
            accuracyChart.data.datasets[1].data.push(logs.val_acc || logs.val_accuracy || logs.acc || logs.accuracy);
            accuracyChart.update('none');
        }

        // メトリクス更新
        function updateMetrics(duration) {
            const lastHistory = trainingHistory[trainingHistory.length - 1];
            if (lastHistory) {
                document.getElementById('accuracyValue').textContent = 
                    `${(lastHistory.accuracy * 100).toFixed(1)}%`;
                document.getElementById('lossValue').textContent = 
                    lastHistory.loss.toFixed(4);
                document.getElementById('epochValue').textContent = lastHistory.epoch;
            }
            document.getElementById('timeValue').textContent = duration.toFixed(1);
        }

        // 予測実行
        async function predictSample() {
            if (!model || !dataset) {
                alert('モデルとデータセットを準備してから予測を実行してください');
                return;
            }
            
            try {
                // テストデータから1サンプル取得
                const sampleIndex = Math.floor(Math.random() * 10);
                const sample = dataset.xTest.slice([sampleIndex, 0], [1, -1]);
                
                // 予測実行
                const prediction = model.predict(sample);
                const predictionData = await prediction.data();
                
                // 予測結果表示
                updatePredictionDisplay(predictionData);
                
                sample.dispose();
                prediction.dispose();
                
            } catch (error) {
                console.error('予測エラー:', error);
                alert('予測中にエラーが発生しました: ' + error.message);
            }
        }

        // 予測結果表示更新
        function updatePredictionDisplay(predictions) {
            const grid = document.getElementById('predictionGrid');
            
            if (predictions.length <= 10) {
                let html = '';
                predictions.forEach((prob, index) => {
                    html += `
                        <div class="prediction-item">
                            <div class="prediction-value">${(prob * 100).toFixed(1)}%</div>
                            <div>クラス ${index}</div>
                        </div>
                    `;
                });
                grid.innerHTML = html;
            } else {
                // 回帰の場合
                grid.innerHTML = `
                    <div class="prediction-item" style="grid-column: 1 / -1;">
                        <div class="prediction-value">${predictions[0].toFixed(4)}</div>
                        <div>予測値</div>
                    </div>
                `;
            }
        }

        // 実験履歴追加
        function addExperiment(experiment) {
            experiments.unshift(experiment);
            updateExperimentHistory();
        }

        // 実験履歴更新
        function updateExperimentHistory() {
            const history = document.getElementById('experimentHistory');
            
            if (experiments.length === 0) {
                history.innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); padding: 2rem;">
                        実験履歴はまだありません
                    </div>
                `;
                return;
            }
            
            let html = '';
            experiments.slice(0, 5).forEach((exp, index) => {
                html += `
                    <div class="experiment-item">
                        <strong>実験 #${experiments.length - index}</strong> - ${exp.dataset.toUpperCase()}
                        <div class="experiment-meta">
                            精度: ${(exp.finalAccuracy * 100).toFixed(1)}% | 
                            損失: ${exp.finalLoss.toFixed(4)} | 
                            時間: ${exp.duration.toFixed(1)}秒
                        </div>
                        <div class="experiment-meta">
                            ${exp.timestamp.toLocaleString()}
                        </div>
                    </div>
                `;
            });
            
            history.innerHTML = html;
        }

        // モデルリセット
        function resetModel() {
            if (model) {
                model.dispose();
                model = null;
            }
            
            isTraining = false;
            trainingHistory = [];
            
            // チャートクリア
            lossChart.data.labels = [];
            lossChart.data.datasets.forEach(dataset => dataset.data = []);
            lossChart.update();
            
            accuracyChart.data.labels = [];
            accuracyChart.data.datasets.forEach(dataset => dataset.data = []);
            accuracyChart.update();
            
            // UI リセット
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressText').textContent = 'エポック: 0/0 | 損失: - | 精度: -';
            
            document.getElementById('accuracyValue').textContent = '-';
            document.getElementById('lossValue').textContent = '-';
            document.getElementById('epochValue').textContent = '-';
            document.getElementById('timeValue').textContent = '-';
            
            document.getElementById('predictionGrid').innerHTML = `
                <div class="prediction-item">
                    <div class="prediction-value">-</div>
                    <div>待機中</div>
                </div>
            `;
            
            updateModelSummary('まだモデルが構築されていません');
            updateNetworkVisualization();
            updateStatus('リセット完了', 'idle');
            updateTrainingControls(false);
        }

        // ステータス更新
        function updateStatus(text, status) {
            document.getElementById('statusText').textContent = text;
            const indicator = document.getElementById('statusIndicator');
            
            indicator.className = `status-indicator status-${status}`;
            
            if (status === 'training') {
                document.querySelector('.workspace').classList.add('training-pulse');
            } else {
                document.querySelector('.workspace').classList.remove('training-pulse');
            }
        }

        // 学習制御ボタン更新
        function updateTrainingControls(training) {
            document.getElementById('trainBtn').disabled = training;
            document.getElementById('stopBtn').disabled = !training;
        }

        // エラーハンドリング
        window.addEventListener('error', function(event) {
            console.error('アプリケーションエラー:', event.error);
            updateStatus('エラーが発生しました', 'error');
        });

        // メモリ使用量監視
        setInterval(() => {
            if (tf.memory) {
                const memory = tf.memory();
                console.log('TensorFlow.js メモリ使用量:', memory);
                
                // メモリが多すぎる場合は警告
                if (memory.numTensors > 1000) {
                    console.warn('メモリ使用量が多くなっています。リセットを検討してください。');
                }
            }
        }, 30000);

        console.log('🧠 ディープラーニングシステム初期化完了');
    </script>
</body>
</html>