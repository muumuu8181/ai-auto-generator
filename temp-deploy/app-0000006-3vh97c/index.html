<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ‡ã‚£ãƒ¼ãƒ—ãƒ©ãƒ¼ãƒ‹ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ  - çµ±åˆAIå®Ÿé¨“ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ </title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #2563eb;
            --secondary-color: #7c3aed;
            --accent-color: #059669;
            --danger-color: #dc2626;
            --warning-color: #d97706;
            --bg-color: #0f172a;
            --surface-color: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border-color: #334155;
            --gradient: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-color);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: auto;
        }

        .header {
            background: var(--gradient);
            padding: 1rem 2rem;
            box-shadow: 0 4px 20px rgba(37, 99, 235, 0.3);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .main-container {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            gap: 1rem;
            padding: 1rem;
            max-width: 1800px;
            margin: 0 auto;
            min-height: calc(100vh - 100px);
        }

        .panel {
            background: var(--surface-color);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .panel h2 {
            color: var(--text-primary);
            margin-bottom: 1rem;
            font-size: 1.2rem;
            font-weight: 600;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }

        /* ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰ã‚¨ãƒªã‚¢ */
        .model-builder {
            overflow-y: auto;
            max-height: calc(100vh - 150px);
        }

        .layer-palette {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .layer-button {
            padding: 0.75rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .layer-button:hover {
            background: #1d4ed8;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .network-visual {
            min-height: 300px;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            position: relative;
            background: rgba(37, 99, 235, 0.05);
        }

        .layer-node {
            background: var(--gradient);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            margin: 0.5rem 0;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .layer-node:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(37, 99, 235, 0.4);
        }

        .layer-node::after {
            content: 'â†“';
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--text-secondary);
        }

        .layer-node:last-child::after {
            display: none;
        }

        /* ãƒ¡ã‚¤ãƒ³ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ */
        .workspace {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .controls-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .control-group {
            background: rgba(37, 99, 235, 0.1);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .control-group label {
            display: block;
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .control-input {
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .dataset-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .dataset-button {
            padding: 0.75rem;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .dataset-button:hover, .dataset-button.active {
            background: #047857;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(5, 150, 105, 0.3);
        }

        .action-buttons {
            display: flex;
            gap: 1rem;
            margin: 1rem 0;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-secondary {
            background: var(--secondary-color);
            color: white;
        }

        .btn-success {
            background: var(--accent-color);
            color: white;
        }

        .btn-danger {
            background: var(--danger-color);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* å¯è¦–åŒ–ã‚¨ãƒªã‚¢ */
        .visualization {
            overflow-y: auto;
            max-height: calc(100vh - 150px);
        }

        .chart-container {
            position: relative;
            height: 250px;
            margin: 1rem 0;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 1rem;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
        }

        .metric-card {
            background: rgba(37, 99, 235, 0.1);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent-color);
            display: block;
        }

        .metric-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--gradient);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .status-idle {
            background: var(--text-secondary);
        }

        .status-training {
            background: var(--warning-color);
            animation: pulse 1.5s infinite;
        }

        .status-complete {
            background: var(--accent-color);
        }

        .status-error {
            background: var(--danger-color);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .prediction-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .prediction-item {
            background: rgba(0,0,0,0.3);
            padding: 0.5rem;
            border-radius: 6px;
            text-align: center;
            font-size: 0.8rem;
            border: 1px solid var(--border-color);
        }

        .prediction-value {
            font-weight: 700;
            color: var(--accent-color);
        }

        .experiment-history {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 1rem;
        }

        .experiment-item {
            background: rgba(0,0,0,0.2);
            padding: 0.75rem;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            border-left: 3px solid var(--primary-color);
        }

        .experiment-meta {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
            }
            
            .panel {
                max-height: none;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 0.5rem;
                gap: 0.5rem;
            }
            
            .header {
                padding: 0.75rem 1rem;
            }
            
            .header h1 {
                font-size: 1.4rem;
            }
            
            .controls-row {
                grid-template-columns: 1fr;
            }
            
            .action-buttons {
                flex-direction: column;
            }
            
            .layer-palette {
                grid-template-columns: 1fr;
            }
        }

        /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .training-pulse {
            animation: trainingPulse 2s infinite;
        }

        @keyframes trainingPulse {
            0%, 100% { 
                box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.7);
            }
            70% { 
                box-shadow: 0 0 0 10px rgba(37, 99, 235, 0);
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ§  ãƒ‡ã‚£ãƒ¼ãƒ—ãƒ©ãƒ¼ãƒ‹ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ  - çµ±åˆAIå®Ÿé¨“ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ </h1>
    </div>

    <div class="main-container">
        <!-- ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰ãƒ‘ãƒãƒ« -->
        <div class="panel model-builder">
            <h2>ğŸ—ï¸ ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰</h2>
            
            <div class="layer-palette">
                <button class="layer-button" onclick="addLayer('dense')">Dense</button>
                <button class="layer-button" onclick="addLayer('conv2d')">Conv2D</button>
                <button class="layer-button" onclick="addLayer('maxpool')">MaxPool</button>
                <button class="layer-button" onclick="addLayer('dropout')">Dropout</button>
                <button class="layer-button" onclick="addLayer('flatten')">Flatten</button>
                <button class="layer-button" onclick="addLayer('activation')">Activation</button>
            </div>

            <div class="network-visual" id="networkVisual">
                <div style="text-align: center; color: var(--text-secondary); margin-top: 50px;">
                    ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’æ§‹ç¯‰ã—ã¦ãã ã•ã„
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-secondary" onclick="clearNetwork()">ã‚¯ãƒªã‚¢</button>
                <button class="btn btn-success" onclick="buildModel()">ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰</button>
            </div>

            <div class="control-group">
                <label>ãƒ¢ãƒ‡ãƒ«æ§‹æˆ</label>
                <div id="modelSummary" style="font-size: 0.8rem; color: var(--text-secondary);">
                    ã¾ã ãƒ¢ãƒ‡ãƒ«ãŒæ§‹ç¯‰ã•ã‚Œã¦ã„ã¾ã›ã‚“
                </div>
            </div>
        </div>

        <!-- ãƒ¡ã‚¤ãƒ³ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ -->
        <div class="panel workspace">
            <h2>ğŸ¯ å­¦ç¿’åˆ¶å¾¡ & ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ</h2>
            
            <div class="dataset-selector">
                <button class="dataset-button active" onclick="selectDataset('mnist')">MNIST</button>
                <button class="dataset-button" onclick="selectDataset('xor')">XOR</button>
                <button class="dataset-button" onclick="selectDataset('linear')">ç·šå½¢å›å¸°</button>
                <button class="dataset-button" onclick="selectDataset('classification')">2Dåˆ†é¡</button>
            </div>

            <div class="controls-row">
                <div class="control-group">
                    <label>å­¦ç¿’ç‡</label>
                    <input type="range" id="learningRate" class="control-input" min="0.0001" max="0.1" step="0.0001" value="0.001">
                    <span id="learningRateValue">0.001</span>
                </div>
                
                <div class="control-group">
                    <label>ãƒãƒƒãƒã‚µã‚¤ã‚º</label>
                    <input type="range" id="batchSize" class="control-input" min="16" max="128" step="16" value="32">
                    <span id="batchSizeValue">32</span>
                </div>
                
                <div class="control-group">
                    <label>ã‚¨ãƒãƒƒã‚¯æ•°</label>
                    <input type="range" id="epochs" class="control-input" min="1" max="100" step="1" value="10">
                    <span id="epochsValue">10</span>
                </div>
                
                <div class="control-group">
                    <label>ã‚ªãƒ—ãƒ†ã‚£ãƒã‚¤ã‚¶ãƒ¼</label>
                    <select id="optimizer" class="control-input">
                        <option value="adam">Adam</option>
                        <option value="sgd">SGD</option>
                        <option value="rmsprop">RMSprop</option>
                    </select>
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" id="trainBtn" onclick="startTraining()">ğŸš€ å­¦ç¿’é–‹å§‹</button>
                <button class="btn btn-danger" id="stopBtn" onclick="stopTraining()" disabled>â¹ï¸ åœæ­¢</button>
                <button class="btn btn-secondary" onclick="resetModel()">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
                <button class="btn btn-success" onclick="predictSample()">ğŸ”® äºˆæ¸¬å®Ÿè¡Œ</button>
            </div>

            <div class="control-group">
                <label>å­¦ç¿’é€²æ—</label>
                <div style="display: flex; align-items: center; margin: 0.5rem 0;">
                    <span class="status-indicator status-idle" id="statusIndicator"></span>
                    <span id="statusText">å¾…æ©Ÿä¸­</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
                <div style="font-size: 0.8rem; color: var(--text-secondary);" id="progressText">
                    ã‚¨ãƒãƒƒã‚¯: 0/0 | æå¤±: - | ç²¾åº¦: -
                </div>
            </div>

            <div class="chart-container">
                <canvas id="lossChart"></canvas>
            </div>
        </div>

        <!-- å¯è¦–åŒ–ãƒ»çµæœãƒ‘ãƒãƒ« -->
        <div class="panel visualization">
            <h2>ğŸ“Š å¯è¦–åŒ– & çµæœ</h2>
            
            <div class="metrics-grid">
                <div class="metric-card">
                    <span class="metric-value" id="accuracyValue">-</span>
                    <span class="metric-label">ç²¾åº¦</span>
                </div>
                <div class="metric-card">
                    <span class="metric-value" id="lossValue">-</span>
                    <span class="metric-label">æå¤±</span>
                </div>
                <div class="metric-card">
                    <span class="metric-value" id="epochValue">-</span>
                    <span class="metric-label">ã‚¨ãƒãƒƒã‚¯</span>
                </div>
                <div class="metric-card">
                    <span class="metric-value" id="timeValue">-</span>
                    <span class="metric-label">æ™‚é–“(ç§’)</span>
                </div>
            </div>

            <div class="control-group">
                <label>äºˆæ¸¬çµæœ</label>
                <div class="prediction-grid" id="predictionGrid">
                    <div class="prediction-item">
                        <div class="prediction-value">-</div>
                        <div>å¾…æ©Ÿä¸­</div>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <canvas id="accuracyChart"></canvas>
            </div>

            <div class="control-group">
                <label>ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å¯è¦–åŒ–</label>
                <div id="networkViz" style="min-height: 150px; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 1rem; margin-top: 0.5rem;">
                    <div style="text-align: center; color: var(--text-secondary); margin-top: 50px;">
                        ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰å¾Œã«è¡¨ç¤ºã•ã‚Œã¾ã™
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label>å®Ÿé¨“å±¥æ­´</label>
                <div class="experiment-history" id="experimentHistory">
                    <div style="text-align: center; color: var(--text-secondary); padding: 2rem;">
                        å®Ÿé¨“å±¥æ­´ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let model = null;
        let dataset = null;
        let isTraining = false;
        let trainingHistory = [];
        let lossChart = null;
        let accuracyChart = null;
        let currentDataset = 'mnist';
        let networkLayers = [];
        let experiments = [];

        // TensorFlow.js åˆæœŸåŒ–ç¢ºèª
        console.log('TensorFlow.js version:', tf.version.tfjs);

        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initializeCharts();
            setupEventListeners();
            loadDataset('mnist');
            updateStatus('å¾…æ©Ÿä¸­', 'idle');
        });

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        function setupEventListeners() {
            document.getElementById('learningRate').addEventListener('input', function(e) {
                document.getElementById('learningRateValue').textContent = e.target.value;
            });
            
            document.getElementById('batchSize').addEventListener('input', function(e) {
                document.getElementById('batchSizeValue').textContent = e.target.value;
            });
            
            document.getElementById('epochs').addEventListener('input', function(e) {
                document.getElementById('epochsValue').textContent = e.target.value;
            });
        }

        // ãƒãƒ£ãƒ¼ãƒˆåˆæœŸåŒ–
        function initializeCharts() {
            const ctx1 = document.getElementById('lossChart').getContext('2d');
            const ctx2 = document.getElementById('accuracyChart').getContext('2d');

            lossChart = new Chart(ctx1, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'å­¦ç¿’æå¤±',
                        data: [],
                        borderColor: '#dc2626',
                        backgroundColor: 'rgba(220, 38, 38, 0.1)',
                        tension: 0.3
                    }, {
                        label: 'æ¤œè¨¼æå¤±',
                        data: [],
                        borderColor: '#7c3aed',
                        backgroundColor: 'rgba(124, 58, 237, 0.1)',
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#f1f5f9' }
                        }
                    },
                    scales: {
                        x: { 
                            ticks: { color: '#94a3b8' },
                            grid: { color: '#334155' }
                        },
                        y: { 
                            ticks: { color: '#94a3b8' },
                            grid: { color: '#334155' }
                        }
                    }
                }
            });

            accuracyChart = new Chart(ctx2, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'å­¦ç¿’ç²¾åº¦',
                        data: [],
                        borderColor: '#059669',
                        backgroundColor: 'rgba(5, 150, 105, 0.1)',
                        tension: 0.3
                    }, {
                        label: 'æ¤œè¨¼ç²¾åº¦',
                        data: [],
                        borderColor: '#2563eb',
                        backgroundColor: 'rgba(37, 99, 235, 0.1)',
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#f1f5f9' }
                        }
                    },
                    scales: {
                        x: { 
                            ticks: { color: '#94a3b8' },
                            grid: { color: '#334155' }
                        },
                        y: { 
                            ticks: { color: '#94a3b8' },
                            grid: { color: '#334155' },
                            min: 0,
                            max: 1
                        }
                    }
                }
            });
        }

        // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆé¸æŠ
        async function selectDataset(type) {
            currentDataset = type;
            
            // ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹æ›´æ–°
            document.querySelectorAll('.dataset-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            await loadDataset(type);
            updateStatus(`${type.toUpperCase()}ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿å®Œäº†`, 'complete');
        }

        // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿
        async function loadDataset(type) {
            try {
                switch(type) {
                    case 'mnist':
                        dataset = await loadMNISTData();
                        break;
                    case 'xor':
                        dataset = generateXORData();
                        break;
                    case 'linear':
                        dataset = generateLinearData();
                        break;
                    case 'classification':
                        dataset = generate2DClassificationData();
                        break;
                }
                
                console.log(`${type} ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿å®Œäº†:`, dataset);
            } catch (error) {
                console.error('ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                updateStatus('ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼', 'error');
            }
        }

        // MNIST ãƒ‡ãƒ¼ã‚¿ï¼ˆç°¡æ˜“ç‰ˆï¼‰
        async function loadMNISTData() {
            const numSamples = 1000;
            const imageSize = 28 * 28;
            
            // ç°¡æ˜“çš„ãªMNISTãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆå®Ÿéš›ã®MNISTãƒ‡ãƒ¼ã‚¿ã®ä»£ç”¨ï¼‰
            const xTrain = tf.randomNormal([numSamples, imageSize]);
            const yTrain = tf.randomUniform([numSamples], 0, 10, 'int32');
            const yTrainOneHot = tf.oneHot(yTrain, 10);
            
            return {
                xTrain: xTrain,
                yTrain: yTrainOneHot,
                xTest: tf.randomNormal([200, imageSize]),
                yTest: tf.oneHot(tf.randomUniform([200], 0, 10, 'int32'), 10),
                inputShape: [imageSize],
                outputShape: 10,
                type: 'classification'
            };
        }

        // XOR ãƒ‡ãƒ¼ã‚¿
        function generateXORData() {
            const data = [
                [0, 0, 0],
                [0, 1, 1],
                [1, 0, 1],
                [1, 1, 0]
            ];
            
            const numSamples = 1000;
            const samples = [];
            const labels = [];
            
            for (let i = 0; i < numSamples; i++) {
                const sample = data[Math.floor(Math.random() * data.length)];
                samples.push([sample[0], sample[1]]);
                labels.push([sample[2]]);
            }
            
            return {
                xTrain: tf.tensor2d(samples),
                yTrain: tf.tensor2d(labels),
                xTest: tf.tensor2d(samples.slice(0, 200)),
                yTest: tf.tensor2d(labels.slice(0, 200)),
                inputShape: [2],
                outputShape: 1,
                type: 'binary'
            };
        }

        // ç·šå½¢å›å¸°ãƒ‡ãƒ¼ã‚¿
        function generateLinearData() {
            const numSamples = 1000;
            const x = tf.randomNormal([numSamples, 1]);
            const y = x.mul(2).add(1).add(tf.randomNormal([numSamples, 1], 0, 0.1));
            
            return {
                xTrain: x,
                yTrain: y,
                xTest: tf.randomNormal([200, 1]),
                yTest: tf.randomNormal([200, 1]),
                inputShape: [1],
                outputShape: 1,
                type: 'regression'
            };
        }

        // 2Dåˆ†é¡ãƒ‡ãƒ¼ã‚¿
        function generate2DClassificationData() {
            const numSamples = 1000;
            const x = tf.randomNormal([numSamples, 2]);
            const y = x.sum(axis=1).greater(0).cast('int32');
            const yOneHot = tf.oneHot(y, 2);
            
            return {
                xTrain: x,
                yTrain: yOneHot,
                xTest: tf.randomNormal([200, 2]),
                yTest: tf.oneHot(tf.randomNormal([200, 2]).sum(axis=1).greater(0).cast('int32'), 2),
                inputShape: [2],
                outputShape: 2,
                type: 'classification'
            };
        }

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼è¿½åŠ 
        function addLayer(layerType) {
            const layer = {
                type: layerType,
                id: Date.now(),
                params: getDefaultLayerParams(layerType)
            };
            
            networkLayers.push(layer);
            updateNetworkVisual();
        }

        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        function getDefaultLayerParams(layerType) {
            switch(layerType) {
                case 'dense':
                    return { units: 64, activation: 'relu' };
                case 'conv2d':
                    return { filters: 32, kernelSize: 3, activation: 'relu' };
                case 'maxpool':
                    return { poolSize: 2 };
                case 'dropout':
                    return { rate: 0.5 };
                case 'flatten':
                    return {};
                case 'activation':
                    return { activation: 'relu' };
                default:
                    return {};
            }
        }

        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å¯è¦–åŒ–æ›´æ–°
        function updateNetworkVisual() {
            const visual = document.getElementById('networkVisual');
            
            if (networkLayers.length === 0) {
                visual.innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); margin-top: 50px;">
                        ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’æ§‹ç¯‰ã—ã¦ãã ã•ã„
                    </div>
                `;
                return;
            }
            
            let html = '';
            networkLayers.forEach((layer, index) => {
                const params = Object.entries(layer.params)
                    .map(([key, value]) => `${key}: ${value}`)
                    .join(', ');
                
                html += `
                    <div class="layer-node" onclick="removeLayer(${index})">
                        <strong>${layer.type.toUpperCase()}</strong>
                        ${params ? `<br><small>${params}</small>` : ''}
                    </div>
                `;
            });
            
            visual.innerHTML = html;
        }

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼å‰Šé™¤
        function removeLayer(index) {
            networkLayers.splice(index, 1);
            updateNetworkVisual();
        }

        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¯ãƒªã‚¢
        function clearNetwork() {
            networkLayers = [];
            updateNetworkVisual();
            updateModelSummary('ã¾ã ãƒ¢ãƒ‡ãƒ«ãŒæ§‹ç¯‰ã•ã‚Œã¦ã„ã¾ã›ã‚“');
        }

        // ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰
        async function buildModel() {
            try {
                if (networkLayers.length === 0) {
                    alert('ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½åŠ ã—ã¦ã‹ã‚‰ãƒ¢ãƒ‡ãƒ«ã‚’æ§‹ç¯‰ã—ã¦ãã ã•ã„');
                    return;
                }

                model = tf.sequential();
                
                // å…¥åŠ›ãƒ¬ã‚¤ãƒ¤ãƒ¼
                const inputShape = dataset ? dataset.inputShape : [784];
                let isFirstLayer = true;
                
                for (const layer of networkLayers) {
                    let tfLayer;
                    
                    switch(layer.type) {
                        case 'dense':
                            tfLayer = tf.layers.dense({
                                units: layer.params.units,
                                activation: layer.params.activation,
                                inputShape: isFirstLayer ? inputShape : undefined
                            });
                            break;
                        case 'conv2d':
                            tfLayer = tf.layers.conv2d({
                                filters: layer.params.filters,
                                kernelSize: layer.params.kernelSize,
                                activation: layer.params.activation,
                                inputShape: isFirstLayer ? [28, 28, 1] : undefined
                            });
                            break;
                        case 'maxpool':
                            tfLayer = tf.layers.maxPooling2d({
                                poolSize: layer.params.poolSize
                            });
                            break;
                        case 'dropout':
                            tfLayer = tf.layers.dropout({
                                rate: layer.params.rate
                            });
                            break;
                        case 'flatten':
                            tfLayer = tf.layers.flatten();
                            break;
                        case 'activation':
                            tfLayer = tf.layers.activation({
                                activation: layer.params.activation
                            });
                            break;
                    }
                    
                    if (tfLayer) {
                        model.add(tfLayer);
                        isFirstLayer = false;
                    }
                }
                
                // å‡ºåŠ›ãƒ¬ã‚¤ãƒ¤ãƒ¼è‡ªå‹•è¿½åŠ 
                if (dataset) {
                    const outputActivation = dataset.type === 'binary' ? 'sigmoid' : 
                                           dataset.type === 'classification' ? 'softmax' : 'linear';
                    model.add(tf.layers.dense({
                        units: dataset.outputShape,
                        activation: outputActivation
                    }));
                }
                
                // ãƒ¢ãƒ‡ãƒ«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
                const optimizer = document.getElementById('optimizer').value;
                const learningRate = parseFloat(document.getElementById('learningRate').value);
                
                model.compile({
                    optimizer: tf.train.adam(learningRate),
                    loss: dataset && dataset.type === 'binary' ? 'binaryCrossentropy' :
                          dataset && dataset.type === 'classification' ? 'categoricalCrossentropy' : 'meanSquaredError',
                    metrics: ['accuracy']
                });
                
                updateModelSummary(`${model.layers.length}å±¤ã®ãƒ¢ãƒ‡ãƒ«ãŒæ§‹ç¯‰ã•ã‚Œã¾ã—ãŸ`);
                updateNetworkVisualization();
                updateStatus('ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰å®Œäº†', 'complete');
                
                console.log('ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰å®Œäº†:', model);
                
            } catch (error) {
                console.error('ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰ã‚¨ãƒ©ãƒ¼:', error);
                updateStatus('ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰ã‚¨ãƒ©ãƒ¼', 'error');
                alert('ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message);
            }
        }

        // ãƒ¢ãƒ‡ãƒ«è¦ç´„æ›´æ–°
        function updateModelSummary(text) {
            document.getElementById('modelSummary').textContent = text;
        }

        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å¯è¦–åŒ–æ›´æ–°
        function updateNetworkVisualization() {
            const viz = document.getElementById('networkViz');
            
            if (!model) {
                viz.innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); margin-top: 50px;">
                        ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰å¾Œã«è¡¨ç¤ºã•ã‚Œã¾ã™
                    </div>
                `;
                return;
            }
            
            let html = '<div style="font-size: 0.8rem;">';
            model.layers.forEach((layer, index) => {
                const outputShape = layer.outputShape ? 
                    layer.outputShape.slice(1).join(' Ã— ') : 'unknown';
                html += `
                    <div style="padding: 0.5rem; background: rgba(37, 99, 235, 0.1); margin: 0.25rem 0; border-radius: 4px;">
                        <strong>${layer.getClassName()}</strong><br>
                        <small>å‡ºåŠ›: ${outputShape}</small>
                    </div>
                `;
            });
            html += '</div>';
            
            viz.innerHTML = html;
        }

        // å­¦ç¿’é–‹å§‹
        async function startTraining() {
            if (!model || !dataset) {
                alert('ãƒ¢ãƒ‡ãƒ«ã¨ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’æº–å‚™ã—ã¦ã‹ã‚‰å­¦ç¿’ã‚’é–‹å§‹ã—ã¦ãã ã•ã„');
                return;
            }
            
            isTraining = true;
            updateTrainingControls(true);
            updateStatus('å­¦ç¿’ä¸­...', 'training');
            
            const epochs = parseInt(document.getElementById('epochs').value);
            const batchSize = parseInt(document.getElementById('batchSize').value);
            
            const startTime = Date.now();
            trainingHistory = [];
            
            try {
                const history = await model.fit(dataset.xTrain, dataset.yTrain, {
                    epochs: epochs,
                    batchSize: batchSize,
                    validationSplit: 0.2,
                    callbacks: {
                        onEpochEnd: async (epoch, logs) => {
                            if (!isTraining) return;
                            
                            const progress = ((epoch + 1) / epochs) * 100;
                            updateProgress(progress, epoch + 1, epochs, logs.loss, logs.acc || logs.accuracy);
                            updateCharts(epoch + 1, logs);
                            
                            trainingHistory.push({
                                epoch: epoch + 1,
                                loss: logs.loss,
                                accuracy: logs.acc || logs.accuracy,
                                valLoss: logs.val_loss,
                                valAccuracy: logs.val_acc || logs.val_accuracy
                            });
                            
                            // UIæ›´æ–°ã®ãŸã‚å°‘ã—å¾…æ©Ÿ
                            await tf.nextFrame();
                        }
                    }
                });
                
                if (isTraining) {
                    const endTime = Date.now();
                    const duration = (endTime - startTime) / 1000;
                    
                    updateStatus('å­¦ç¿’å®Œäº†', 'complete');
                    updateMetrics(duration);
                    
                    // å®Ÿé¨“å±¥æ­´ã«è¿½åŠ 
                    addExperiment({
                        timestamp: new Date(),
                        dataset: currentDataset,
                        epochs: epochs,
                        batchSize: batchSize,
                        finalLoss: trainingHistory[trainingHistory.length - 1]?.loss || 0,
                        finalAccuracy: trainingHistory[trainingHistory.length - 1]?.accuracy || 0,
                        duration: duration
                    });
                }
                
            } catch (error) {
                console.error('å­¦ç¿’ã‚¨ãƒ©ãƒ¼:', error);
                updateStatus('å­¦ç¿’ã‚¨ãƒ©ãƒ¼', 'error');
                alert('å­¦ç¿’ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message);
            } finally {
                isTraining = false;
                updateTrainingControls(false);
            }
        }

        // å­¦ç¿’åœæ­¢
        function stopTraining() {
            isTraining = false;
            updateStatus('å­¦ç¿’åœæ­¢', 'idle');
            updateTrainingControls(false);
        }

        // é€²æ—æ›´æ–°
        function updateProgress(progress, epoch, totalEpochs, loss, accuracy) {
            document.getElementById('progressFill').style.width = `${progress}%`;
            document.getElementById('progressText').textContent = 
                `ã‚¨ãƒãƒƒã‚¯: ${epoch}/${totalEpochs} | æå¤±: ${loss.toFixed(4)} | ç²¾åº¦: ${(accuracy * 100).toFixed(1)}%`;
        }

        // ãƒãƒ£ãƒ¼ãƒˆæ›´æ–°
        function updateCharts(epoch, logs) {
            // æå¤±ãƒãƒ£ãƒ¼ãƒˆ
            lossChart.data.labels.push(epoch);
            lossChart.data.datasets[0].data.push(logs.loss);
            lossChart.data.datasets[1].data.push(logs.val_loss || logs.loss);
            lossChart.update('none');
            
            // ç²¾åº¦ãƒãƒ£ãƒ¼ãƒˆ
            accuracyChart.data.labels.push(epoch);
            accuracyChart.data.datasets[0].data.push(logs.acc || logs.accuracy);
            accuracyChart.data.datasets[1].data.push(logs.val_acc || logs.val_accuracy || logs.acc || logs.accuracy);
            accuracyChart.update('none');
        }

        // ãƒ¡ãƒˆãƒªã‚¯ã‚¹æ›´æ–°
        function updateMetrics(duration) {
            const lastHistory = trainingHistory[trainingHistory.length - 1];
            if (lastHistory) {
                document.getElementById('accuracyValue').textContent = 
                    `${(lastHistory.accuracy * 100).toFixed(1)}%`;
                document.getElementById('lossValue').textContent = 
                    lastHistory.loss.toFixed(4);
                document.getElementById('epochValue').textContent = lastHistory.epoch;
            }
            document.getElementById('timeValue').textContent = duration.toFixed(1);
        }

        // äºˆæ¸¬å®Ÿè¡Œ
        async function predictSample() {
            if (!model || !dataset) {
                alert('ãƒ¢ãƒ‡ãƒ«ã¨ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’æº–å‚™ã—ã¦ã‹ã‚‰äºˆæ¸¬ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„');
                return;
            }
            
            try {
                // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‹ã‚‰1ã‚µãƒ³ãƒ—ãƒ«å–å¾—
                const sampleIndex = Math.floor(Math.random() * 10);
                const sample = dataset.xTest.slice([sampleIndex, 0], [1, -1]);
                
                // äºˆæ¸¬å®Ÿè¡Œ
                const prediction = model.predict(sample);
                const predictionData = await prediction.data();
                
                // äºˆæ¸¬çµæœè¡¨ç¤º
                updatePredictionDisplay(predictionData);
                
                sample.dispose();
                prediction.dispose();
                
            } catch (error) {
                console.error('äºˆæ¸¬ã‚¨ãƒ©ãƒ¼:', error);
                alert('äºˆæ¸¬ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message);
            }
        }

        // äºˆæ¸¬çµæœè¡¨ç¤ºæ›´æ–°
        function updatePredictionDisplay(predictions) {
            const grid = document.getElementById('predictionGrid');
            
            if (predictions.length <= 10) {
                let html = '';
                predictions.forEach((prob, index) => {
                    html += `
                        <div class="prediction-item">
                            <div class="prediction-value">${(prob * 100).toFixed(1)}%</div>
                            <div>ã‚¯ãƒ©ã‚¹ ${index}</div>
                        </div>
                    `;
                });
                grid.innerHTML = html;
            } else {
                // å›å¸°ã®å ´åˆ
                grid.innerHTML = `
                    <div class="prediction-item" style="grid-column: 1 / -1;">
                        <div class="prediction-value">${predictions[0].toFixed(4)}</div>
                        <div>äºˆæ¸¬å€¤</div>
                    </div>
                `;
            }
        }

        // å®Ÿé¨“å±¥æ­´è¿½åŠ 
        function addExperiment(experiment) {
            experiments.unshift(experiment);
            updateExperimentHistory();
        }

        // å®Ÿé¨“å±¥æ­´æ›´æ–°
        function updateExperimentHistory() {
            const history = document.getElementById('experimentHistory');
            
            if (experiments.length === 0) {
                history.innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); padding: 2rem;">
                        å®Ÿé¨“å±¥æ­´ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“
                    </div>
                `;
                return;
            }
            
            let html = '';
            experiments.slice(0, 5).forEach((exp, index) => {
                html += `
                    <div class="experiment-item">
                        <strong>å®Ÿé¨“ #${experiments.length - index}</strong> - ${exp.dataset.toUpperCase()}
                        <div class="experiment-meta">
                            ç²¾åº¦: ${(exp.finalAccuracy * 100).toFixed(1)}% | 
                            æå¤±: ${exp.finalLoss.toFixed(4)} | 
                            æ™‚é–“: ${exp.duration.toFixed(1)}ç§’
                        </div>
                        <div class="experiment-meta">
                            ${exp.timestamp.toLocaleString()}
                        </div>
                    </div>
                `;
            });
            
            history.innerHTML = html;
        }

        // ãƒ¢ãƒ‡ãƒ«ãƒªã‚»ãƒƒãƒˆ
        function resetModel() {
            if (model) {
                model.dispose();
                model = null;
            }
            
            isTraining = false;
            trainingHistory = [];
            
            // ãƒãƒ£ãƒ¼ãƒˆã‚¯ãƒªã‚¢
            lossChart.data.labels = [];
            lossChart.data.datasets.forEach(dataset => dataset.data = []);
            lossChart.update();
            
            accuracyChart.data.labels = [];
            accuracyChart.data.datasets.forEach(dataset => dataset.data = []);
            accuracyChart.update();
            
            // UI ãƒªã‚»ãƒƒãƒˆ
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressText').textContent = 'ã‚¨ãƒãƒƒã‚¯: 0/0 | æå¤±: - | ç²¾åº¦: -';
            
            document.getElementById('accuracyValue').textContent = '-';
            document.getElementById('lossValue').textContent = '-';
            document.getElementById('epochValue').textContent = '-';
            document.getElementById('timeValue').textContent = '-';
            
            document.getElementById('predictionGrid').innerHTML = `
                <div class="prediction-item">
                    <div class="prediction-value">-</div>
                    <div>å¾…æ©Ÿä¸­</div>
                </div>
            `;
            
            updateModelSummary('ã¾ã ãƒ¢ãƒ‡ãƒ«ãŒæ§‹ç¯‰ã•ã‚Œã¦ã„ã¾ã›ã‚“');
            updateNetworkVisualization();
            updateStatus('ãƒªã‚»ãƒƒãƒˆå®Œäº†', 'idle');
            updateTrainingControls(false);
        }

        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
        function updateStatus(text, status) {
            document.getElementById('statusText').textContent = text;
            const indicator = document.getElementById('statusIndicator');
            
            indicator.className = `status-indicator status-${status}`;
            
            if (status === 'training') {
                document.querySelector('.workspace').classList.add('training-pulse');
            } else {
                document.querySelector('.workspace').classList.remove('training-pulse');
            }
        }

        // å­¦ç¿’åˆ¶å¾¡ãƒœã‚¿ãƒ³æ›´æ–°
        function updateTrainingControls(training) {
            document.getElementById('trainBtn').disabled = training;
            document.getElementById('stopBtn').disabled = !training;
        }

        // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        window.addEventListener('error', function(event) {
            console.error('ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼:', event.error);
            updateStatus('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 'error');
        });

        // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç›£è¦–
        setInterval(() => {
            if (tf.memory) {
                const memory = tf.memory();
                console.log('TensorFlow.js ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡:', memory);
                
                // ãƒ¡ãƒ¢ãƒªãŒå¤šã™ãã‚‹å ´åˆã¯è­¦å‘Š
                if (memory.numTensors > 1000) {
                    console.warn('ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒå¤šããªã£ã¦ã„ã¾ã™ã€‚ãƒªã‚»ãƒƒãƒˆã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚');
                }
            }
        }, 30000);

        console.log('ğŸ§  ãƒ‡ã‚£ãƒ¼ãƒ—ãƒ©ãƒ¼ãƒ‹ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†');
    </script>
</body>
</html>