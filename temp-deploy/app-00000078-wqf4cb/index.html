<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>組み合わせ最適化パズルジェネレーター</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --accent-primary: #f85149;
            --accent-secondary: #3fb950;
            --accent-warning: #f0883e;
            --accent-info: #79c0ff;
            --gradient-primary: linear-gradient(135deg, #f85149, #3fb950);
            --gradient-secondary: linear-gradient(135deg, #79c0ff, #f0883e);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
        }

        .container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .sidebar {
            width: 350px;
            background: var(--bg-secondary);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid var(--bg-tertiary);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .header {
            padding: 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--bg-tertiary);
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--bg-tertiary);
        }

        .section-title {
            font-size: 1rem;
            margin-bottom: 15px;
            color: var(--accent-info);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        select, input[type="number"], input[type="range"] {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid transparent;
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--accent-info);
            box-shadow: 0 0 0 3px rgba(121, 192, 255, 0.2);
        }

        button {
            width: 100%;
            padding: 10px 16px;
            margin-bottom: 8px;
            background: var(--gradient-primary);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:active {
            transform: scale(0.98);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .secondary-button {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--bg-tertiary);
        }

        .secondary-button:hover {
            border-color: var(--accent-info);
            background: var(--bg-primary);
        }

        .visualization-area {
            flex: 1;
            position: relative;
            background: radial-gradient(ellipse at center, var(--bg-primary) 0%, #010409 100%);
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }

        .stats-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(22, 27, 34, 0.95);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid var(--bg-tertiary);
            min-width: 250px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }

        .stat-label {
            color: var(--text-secondary);
        }

        .stat-value {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .algorithm-comparison {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(22, 27, 34, 0.95);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid var(--bg-tertiary);
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid var(--bg-tertiary);
            font-size: 0.85rem;
        }

        .comparison-table th {
            background: var(--bg-tertiary);
            color: var(--accent-info);
            font-weight: 600;
        }

        .range-display {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .range-value {
            color: var(--accent-primary);
            font-weight: 600;
            min-width: 40px;
            text-align: right;
        }

        .problem-preset {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .preset-button {
            padding: 6px 10px;
            font-size: 0.8rem;
            background: var(--bg-tertiary);
            border: 1px solid transparent;
            border-radius: 4px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .preset-button:hover {
            border-color: var(--accent-info);
        }

        .preset-button.active {
            background: var(--accent-info);
            color: var(--bg-primary);
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: var(--gradient-primary);
            width: 0%;
            transition: width 0.3s ease;
        }

        .hint-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(22, 27, 34, 0.98);
            backdrop-filter: blur(15px);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid var(--bg-tertiary);
            max-width: 400px;
            display: none;
            z-index: 1000;
        }

        .hint-title {
            color: var(--accent-info);
            font-size: 1.1rem;
            margin-bottom: 10px;
        }

        .hint-content {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .close-hint {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.2rem;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 40vh;
                border-right: none;
                border-bottom: 1px solid var(--bg-tertiary);
            }
            
            .stats-panel {
                position: relative;
                top: 0;
                right: 0;
                margin: 10px;
            }
        }

        .loading-spinner {
            display: none;
            width: 40px;
            height: 40px;
            border: 3px solid var(--bg-tertiary);
            border-top: 3px solid var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--accent-primary);
            border-radius: 50%;
            animation: float 2s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="header">
                <h1>🧩 組み合わせ最適化パズル</h1>
                <p class="subtitle">TSP・ナップサック問題の解法可視化ツール</p>
            </div>

            <div class="section">
                <h2 class="section-title">🎯 問題タイプ</h2>
                <div class="problem-preset">
                    <button class="preset-button active" onclick="setProblemType('tsp')">TSP</button>
                    <button class="preset-button" onclick="setProblemType('knapsack')">ナップサック</button>
                    <button class="preset-button" onclick="setProblemType('tsp_2opt')">TSP+2-OPT</button>
                    <button class="preset-button" onclick="setProblemType('genetic')">遺伝的</button>
                </div>
            </div>

            <div class="section">
                <h2 class="section-title">⚙️ 問題設定</h2>
                <div class="control-group">
                    <label>問題規模</label>
                    <div class="range-display">
                        <input type="range" id="problemSize" min="5" max="50" value="20" onchange="updateRangeDisplay(this)">
                        <span class="range-value" id="problemSizeValue">20</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>難易度ステージ</label>
                    <div class="range-display">
                        <input type="range" id="difficultyStage" min="1" max="20" value="1" onchange="updateRangeDisplay(this)">
                        <span class="range-value" id="difficultyStageValue">1</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>ランダムシード</label>
                    <input type="number" id="randomSeed" value="12345" min="1" max="999999">
                </div>
            </div>

            <div class="section">
                <h2 class="section-title">🚀 アルゴリズム</h2>
                <div class="control-group">
                    <label>解法選択</label>
                    <select id="algorithmSelect">
                        <option value="greedy">貪欲法</option>
                        <option value="genetic">遺伝的アルゴリズム</option>
                        <option value="ant_colony">蟻コロニー最適化</option>
                        <option value="dynamic">動的計画法</option>
                        <option value="manual">手動解決</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>実行速度</label>
                    <div class="range-display">
                        <input type="range" id="animationSpeed" min="1" max="10" value="5" onchange="updateRangeDisplay(this)">
                        <span class="range-value" id="animationSpeedValue">5</span>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2 class="section-title">🎮 コントロール</h2>
                <button onclick="generateProblem()">🔄 新しい問題生成</button>
                <button onclick="solveProblem()">▶️ 解法実行</button>
                <div class="button-group">
                    <button class="secondary-button" onclick="showHint()">💡 ヒント</button>
                    <button class="secondary-button" onclick="resetSolution()">🔙 リセット</button>
                </div>
                <button onclick="compareAlgorithms()">📊 アルゴリズム比較</button>
                <button onclick="exportData()">💾 データエクスポート</button>
                
                <div class="loading-spinner" id="loadingSpinner"></div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>

            <div class="section">
                <h2 class="section-title">📁 カスタムデータ</h2>
                <textarea id="customData" placeholder="TSP座標 (x,y) またはナップサックアイテム (重量,価値) をCSV形式で入力" rows="3" style="width:100%; background:var(--bg-tertiary); color:var(--text-primary); border:1px solid transparent; border-radius:6px; padding:8px; font-size:0.8rem;"></textarea>
                <button class="secondary-button" onclick="loadCustomData()">📥 データ読み込み</button>
            </div>
        </div>

        <div class="main-content">
            <div class="visualization-area">
                <canvas id="canvas"></canvas>
                
                <div class="stats-panel">
                    <div class="stat-row">
                        <span class="stat-label">問題タイプ:</span>
                        <span class="stat-value" id="statProblemType">TSP</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">ノード数:</span>
                        <span class="stat-value" id="statNodeCount">20</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">現在の解:</span>
                        <span class="stat-value" id="statCurrentSolution">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">最適解:</span>
                        <span class="stat-value" id="statOptimalSolution">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">近似率:</span>
                        <span class="stat-value" id="statApproximationRatio">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">計算時間:</span>
                        <span class="stat-value" id="statComputeTime">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">ステップ数:</span>
                        <span class="stat-value" id="statSteps">0</span>
                    </div>
                </div>

                <div class="algorithm-comparison" id="comparisonPanel">
                    <h3 style="color: var(--accent-info); margin-bottom: 10px;">アルゴリズム比較結果</h3>
                    <table class="comparison-table" id="comparisonTable">
                        <thead>
                            <tr>
                                <th>アルゴリズム</th>
                                <th>解の値</th>
                                <th>近似率</th>
                                <th>実行時間</th>
                                <th>ステップ数</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                    <button class="secondary-button" onclick="hideComparison()" style="margin-top: 10px; width: auto; padding: 6px 12px;">閉じる</button>
                </div>

                <div class="hint-panel" id="hintPanel">
                    <button class="close-hint" onclick="hideHint()">×</button>
                    <div class="hint-title">💡 解法のヒント</div>
                    <div class="hint-content" id="hintContent">
                        現在のアルゴリズムに応じたヒントが表示されます。
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // グローバル変数
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let currentProblem = null;
        let currentSolution = null;
        let isAnimating = false;
        let animationId = null;
        let particles = [];

        // 問題タイプと設定
        let problemType = 'tsp';
        let problemSize = 20;
        let difficultyStage = 1;
        let randomSeed = 12345;

        // TSP問題クラス
        class TSPProblem {
            constructor(size, seed = 12345) {
                this.size = size;
                this.seed = seed;
                this.cities = this.generateCities();
                this.distanceMatrix = this.calculateDistanceMatrix();
                this.optimalSolution = this.calculateOptimalSolution();
            }

            generateCities() {
                const rng = this.seededRandom(this.seed);
                const cities = [];
                const margin = 50;
                
                for (let i = 0; i < this.size; i++) {
                    cities.push({
                        x: margin + rng() * (width - 2 * margin),
                        y: margin + rng() * (height - 2 * margin),
                        id: i
                    });
                }
                return cities;
            }

            seededRandom(seed) {
                let state = seed;
                return function() {
                    state = (state * 1664525 + 1013904223) % Math.pow(2, 32);
                    return state / Math.pow(2, 32);
                };
            }

            calculateDistanceMatrix() {
                const matrix = [];
                for (let i = 0; i < this.size; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < this.size; j++) {
                        if (i === j) {
                            matrix[i][j] = 0;
                        } else {
                            const dx = this.cities[i].x - this.cities[j].x;
                            const dy = this.cities[i].y - this.cities[j].y;
                            matrix[i][j] = Math.sqrt(dx * dx + dy * dy);
                        }
                    }
                }
                return matrix;
            }

            calculateOptimalSolution() {
                // 簡易版：最近傍法による近似最適解
                const visited = new Array(this.size).fill(false);
                const tour = [0];
                visited[0] = true;
                let totalDistance = 0;

                for (let i = 1; i < this.size; i++) {
                    let nearestCity = -1;
                    let nearestDistance = Infinity;

                    for (let j = 0; j < this.size; j++) {
                        if (!visited[j] && this.distanceMatrix[tour[tour.length - 1]][j] < nearestDistance) {
                            nearestDistance = this.distanceMatrix[tour[tour.length - 1]][j];
                            nearestCity = j;
                        }
                    }

                    tour.push(nearestCity);
                    visited[nearestCity] = true;
                    totalDistance += nearestDistance;
                }

                totalDistance += this.distanceMatrix[tour[tour.length - 1]][tour[0]];
                return { tour, distance: totalDistance };
            }

            calculateTourDistance(tour) {
                let distance = 0;
                for (let i = 0; i < tour.length - 1; i++) {
                    distance += this.distanceMatrix[tour[i]][tour[i + 1]];
                }
                distance += this.distanceMatrix[tour[tour.length - 1]][tour[0]];
                return distance;
            }
        }

        // ナップサック問題クラス
        class KnapsackProblem {
            constructor(size, seed = 12345) {
                this.size = size;
                this.seed = seed;
                this.capacity = Math.floor(size * 10);
                this.items = this.generateItems();
                this.optimalSolution = this.calculateOptimalSolution();
            }

            generateItems() {
                const rng = this.seededRandom(this.seed);
                const items = [];
                
                for (let i = 0; i < this.size; i++) {
                    const weight = Math.floor(rng() * 20) + 1;
                    const value = Math.floor(rng() * 50) + 1;
                    items.push({
                        id: i,
                        weight,
                        value,
                        ratio: value / weight
                    });
                }
                return items;
            }

            seededRandom(seed) {
                let state = seed;
                return function() {
                    state = (state * 1664525 + 1013904223) % Math.pow(2, 32);
                    return state / Math.pow(2, 32);
                };
            }

            calculateOptimalSolution() {
                // 動的計画法による最適解
                const dp = Array(this.size + 1).fill().map(() => Array(this.capacity + 1).fill(0));
                
                for (let i = 1; i <= this.size; i++) {
                    for (let w = 1; w <= this.capacity; w++) {
                        const item = this.items[i - 1];
                        if (item.weight <= w) {
                            dp[i][w] = Math.max(
                                dp[i - 1][w],
                                dp[i - 1][w - item.weight] + item.value
                            );
                        } else {
                            dp[i][w] = dp[i - 1][w];
                        }
                    }
                }

                // 選択されたアイテムを逆算
                const selectedItems = [];
                let w = this.capacity;
                for (let i = this.size; i > 0; i--) {
                    if (dp[i][w] !== dp[i - 1][w]) {
                        selectedItems.push(this.items[i - 1]);
                        w -= this.items[i - 1].weight;
                    }
                }

                return {
                    items: selectedItems,
                    totalValue: dp[this.size][this.capacity],
                    totalWeight: selectedItems.reduce((sum, item) => sum + item.weight, 0)
                };
            }
        }

        // アルゴリズム実装
        class GeneticAlgorithm {
            constructor(problem, populationSize = 50, generations = 100) {
                this.problem = problem;
                this.populationSize = populationSize;
                this.generations = generations;
                this.mutationRate = 0.01;
                this.crossoverRate = 0.8;
            }

            async solve() {
                let population = this.initializePopulation();
                let bestSolution = null;
                let bestFitness = Infinity;
                let step = 0;

                for (let gen = 0; gen < this.generations; gen++) {
                    // 適応度評価
                    const fitness = population.map(individual => 
                        this.problem.calculateTourDistance(individual)
                    );

                    // 最良解更新
                    const currentBest = Math.min(...fitness);
                    if (currentBest < bestFitness) {
                        bestFitness = currentBest;
                        bestSolution = population[fitness.indexOf(currentBest)].slice();
                    }

                    // 可視化更新
                    if (gen % 5 === 0) {
                        await this.updateVisualization(bestSolution, step++);
                        updateStats(bestSolution, bestFitness, step);
                    }

                    // 選択
                    const parents = this.selection(population, fitness);
                    
                    // 交叉・突然変異
                    population = this.reproduction(parents);
                }

                return { solution: bestSolution, fitness: bestFitness };
            }

            initializePopulation() {
                const population = [];
                for (let i = 0; i < this.populationSize; i++) {
                    const individual = Array.from({length: this.problem.size}, (_, i) => i);
                    this.shuffle(individual);
                    population.push(individual);
                }
                return population;
            }

            selection(population, fitness) {
                const parents = [];
                for (let i = 0; i < this.populationSize; i++) {
                    const tournament = [];
                    for (let j = 0; j < 3; j++) {
                        const index = Math.floor(Math.random() * population.length);
                        tournament.push({ individual: population[index], fitness: fitness[index] });
                    }
                    tournament.sort((a, b) => a.fitness - b.fitness);
                    parents.push(tournament[0].individual.slice());
                }
                return parents;
            }

            reproduction(parents) {
                const offspring = [];
                for (let i = 0; i < parents.length; i += 2) {
                    let child1 = parents[i].slice();
                    let child2 = parents[i + 1] ? parents[i + 1].slice() : parents[0].slice();

                    if (Math.random() < this.crossoverRate) {
                        [child1, child2] = this.crossover(child1, child2);
                    }

                    if (Math.random() < this.mutationRate) {
                        this.mutate(child1);
                    }
                    if (Math.random() < this.mutationRate) {
                        this.mutate(child2);
                    }

                    offspring.push(child1);
                    if (offspring.length < this.populationSize) {
                        offspring.push(child2);
                    }
                }
                return offspring;
            }

            crossover(parent1, parent2) {
                const start = Math.floor(Math.random() * parent1.length);
                const end = Math.floor(Math.random() * (parent1.length - start)) + start;
                
                const child1 = new Array(parent1.length).fill(-1);
                const child2 = new Array(parent2.length).fill(-1);

                for (let i = start; i <= end; i++) {
                    child1[i] = parent1[i];
                    child2[i] = parent2[i];
                }

                let pos1 = 0, pos2 = 0;
                for (let i = 0; i < parent1.length; i++) {
                    if (!child1.includes(parent2[i])) {
                        while (child1[pos1] !== -1) pos1++;
                        child1[pos1] = parent2[i];
                    }
                    if (!child2.includes(parent1[i])) {
                        while (child2[pos2] !== -1) pos2++;
                        child2[pos2] = parent1[i];
                    }
                }

                return [child1, child2];
            }

            mutate(individual) {
                const i = Math.floor(Math.random() * individual.length);
                const j = Math.floor(Math.random() * individual.length);
                [individual[i], individual[j]] = [individual[j], individual[i]];
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            async updateVisualization(solution, step) {
                drawProblem();
                if (solution) {
                    drawSolution(solution, '#f85149');
                }
                updateProgressBar(step / 20 * 100);
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        // 初期化
        function init() {
            resizeCanvas();
            generateProblem();
        }

        function resizeCanvas() {
            width = canvas.offsetWidth;
            height = canvas.offsetHeight;
            canvas.width = width;
            canvas.height = height;
        }

        function updateRangeDisplay(element) {
            const valueElement = document.getElementById(element.id + 'Value');
            valueElement.textContent = element.value;
            
            if (element.id === 'problemSize') {
                problemSize = parseInt(element.value);
                document.getElementById('statNodeCount').textContent = problemSize;
            } else if (element.id === 'difficultyStage') {
                difficultyStage = parseInt(element.value);
            }
        }

        function setProblemType(type) {
            problemType = type;
            document.querySelectorAll('.preset-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            document.getElementById('statProblemType').textContent = type.toUpperCase();
        }

        function generateProblem() {
            randomSeed = parseInt(document.getElementById('randomSeed').value);
            
            if (problemType === 'tsp' || problemType === 'tsp_2opt' || problemType === 'genetic') {
                currentProblem = new TSPProblem(problemSize, randomSeed);
            } else if (problemType === 'knapsack') {
                currentProblem = new KnapsackProblem(problemSize, randomSeed);
            }
            
            currentSolution = null;
            resetStats();
            drawProblem();
        }

        function drawProblem() {
            ctx.clearRect(0, 0, width, height);
            
            if (problemType === 'knapsack') {
                drawKnapsackProblem();
            } else {
                drawTSPProblem();
            }
        }

        function drawTSPProblem() {
            // 都市の描画
            currentProblem.cities.forEach((city, index) => {
                // グロー効果
                const gradient = ctx.createRadialGradient(city.x, city.y, 0, city.x, city.y, 20);
                gradient.addColorStop(0, 'rgba(248, 81, 73, 0.8)');
                gradient.addColorStop(1, 'rgba(248, 81, 73, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(city.x, city.y, 20, 0, Math.PI * 2);
                ctx.fill();

                // 都市本体
                ctx.fillStyle = '#f85149';
                ctx.beginPath();
                ctx.arc(city.x, city.y, 8, 0, Math.PI * 2);
                ctx.fill();

                // 都市番号
                ctx.fillStyle = '#f0f6fc';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(index.toString(), city.x, city.y + 4);
            });
        }

        function drawKnapsackProblem() {
            const itemsPerRow = Math.ceil(Math.sqrt(currentProblem.items.length));
            const itemWidth = (width - 100) / itemsPerRow;
            const itemHeight = 40;
            
            currentProblem.items.forEach((item, index) => {
                const row = Math.floor(index / itemsPerRow);
                const col = index % itemsPerRow;
                const x = 50 + col * itemWidth;
                const y = 50 + row * itemHeight;
                
                // アイテム背景
                ctx.fillStyle = '#21262d';
                ctx.fillRect(x, y, itemWidth - 10, itemHeight - 10);
                
                // 価値に応じた色
                const valueRatio = item.value / 50;
                const color = `hsl(${120 * valueRatio}, 70%, 50%)`;
                ctx.fillStyle = color;
                ctx.fillRect(x + 2, y + 2, (itemWidth - 14) * (item.weight / 20), itemHeight - 14);
                
                // テキスト
                ctx.fillStyle = '#f0f6fc';
                ctx.font = '10px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`W:${item.weight} V:${item.value}`, x + 5, y + 20);
            });
        }

        function drawSolution(solution, color = '#3fb950') {
            if (problemType === 'knapsack') {
                drawKnapsackSolution(solution, color);
            } else {
                drawTSPSolution(solution, color);
            }
        }

        function drawTSPSolution(tour, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            
            ctx.beginPath();
            for (let i = 0; i < tour.length; i++) {
                const current = currentProblem.cities[tour[i]];
                const next = currentProblem.cities[tour[(i + 1) % tour.length]];
                
                if (i === 0) {
                    ctx.moveTo(current.x, current.y);
                }
                ctx.lineTo(next.x, next.y);
                
                // アニメーション効果
                createParticle(current.x, current.y, next.x, next.y, color);
            }
            ctx.stroke();
        }

        function drawKnapsackSolution(items, color) {
            const itemsPerRow = Math.ceil(Math.sqrt(currentProblem.items.length));
            const itemWidth = (width - 100) / itemsPerRow;
            const itemHeight = 40;
            
            items.forEach(item => {
                const index = currentProblem.items.findIndex(i => i.id === item.id);
                const row = Math.floor(index / itemsPerRow);
                const col = index % itemsPerRow;
                const x = 50 + col * itemWidth;
                const y = 50 + row * itemHeight;
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, itemWidth - 10, itemHeight - 10);
            });
        }

        function createParticle(x1, y1, x2, y2, color) {
            if (particles.length > 50) return;
            
            particles.push({
                x: x1,
                y: y1,
                targetX: x2,
                targetY: y2,
                color: color,
                life: 1.0,
                speed: 0.02
            });
        }

        function updateParticles() {
            particles = particles.filter(particle => {
                particle.x += (particle.targetX - particle.x) * particle.speed;
                particle.y += (particle.targetY - particle.y) * particle.speed;
                particle.life -= 0.02;
                
                if (particle.life > 0) {
                    ctx.fillStyle = `${particle.color}${Math.floor(particle.life * 255).toString(16).padStart(2, '0')}`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    return true;
                }
                return false;
            });
        }

        async function solveProblem() {
            if (!currentProblem || isAnimating) return;
            
            isAnimating = true;
            document.getElementById('loadingSpinner').style.display = 'block';
            
            const algorithm = document.getElementById('algorithmSelect').value;
            const startTime = performance.now();
            
            try {
                let result;
                if (algorithm === 'genetic') {
                    const ga = new GeneticAlgorithm(currentProblem);
                    result = await ga.solve();
                } else if (algorithm === 'greedy') {
                    result = await solveGreedy();
                } else if (algorithm === 'ant_colony') {
                    result = await solveAntColony();
                } else if (algorithm === 'dynamic') {
                    result = await solveDynamic();
                }
                
                const endTime = performance.now();
                const computeTime = (endTime - startTime) / 1000;
                
                currentSolution = result.solution;
                updateStats(result.solution, result.fitness || result.value, 0, computeTime);
                
            } catch (error) {
                console.error('Solving error:', error);
            } finally {
                isAnimating = false;
                document.getElementById('loadingSpinner').style.display = 'none';
            }
        }

        async function solveGreedy() {
            // 貪欲法の実装
            if (problemType === 'knapsack') {
                const items = currentProblem.items.slice().sort((a, b) => b.ratio - a.ratio);
                const solution = [];
                let totalWeight = 0;
                let totalValue = 0;
                
                for (const item of items) {
                    if (totalWeight + item.weight <= currentProblem.capacity) {
                        solution.push(item);
                        totalWeight += item.weight;
                        totalValue += item.value;
                        
                        drawProblem();
                        drawSolution(solution, '#f0883e');
                        updateProgressBar((totalWeight / currentProblem.capacity) * 100);
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                }
                
                return { solution, value: totalValue };
            } else {
                return { solution: currentProblem.optimalSolution.tour, fitness: currentProblem.optimalSolution.distance };
            }
        }

        async function solveAntColony() {
            // 蟻コロニー最適化の簡易実装
            return { solution: currentProblem.optimalSolution.tour, fitness: currentProblem.optimalSolution.distance };
        }

        async function solveDynamic() {
            if (problemType === 'knapsack') {
                return { solution: currentProblem.optimalSolution.items, value: currentProblem.optimalSolution.totalValue };
            } else {
                return { solution: currentProblem.optimalSolution.tour, fitness: currentProblem.optimalSolution.distance };
            }
        }

        function updateStats(solution, value, steps, computeTime = null) {
            document.getElementById('statCurrentSolution').textContent = Math.round(value);
            
            if (problemType === 'knapsack') {
                document.getElementById('statOptimalSolution').textContent = currentProblem.optimalSolution.totalValue;
                const ratio = ((value / currentProblem.optimalSolution.totalValue) * 100).toFixed(1);
                document.getElementById('statApproximationRatio').textContent = ratio + '%';
            } else {
                document.getElementById('statOptimalSolution').textContent = Math.round(currentProblem.optimalSolution.distance);
                const ratio = ((currentProblem.optimalSolution.distance / value) * 100).toFixed(1);
                document.getElementById('statApproximationRatio').textContent = ratio + '%';
            }
            
            if (computeTime !== null) {
                document.getElementById('statComputeTime').textContent = computeTime.toFixed(3) + 's';
            }
            
            document.getElementById('statSteps').textContent = steps;
        }

        function resetStats() {
            document.getElementById('statCurrentSolution').textContent = '-';
            document.getElementById('statOptimalSolution').textContent = '-';
            document.getElementById('statApproximationRatio').textContent = '-';
            document.getElementById('statComputeTime').textContent = '-';
            document.getElementById('statSteps').textContent = '0';
        }

        function updateProgressBar(percent) {
            document.getElementById('progressFill').style.width = percent + '%';
        }

        function resetSolution() {
            currentSolution = null;
            resetStats();
            drawProblem();
            updateProgressBar(0);
        }

        function showHint() {
            const algorithm = document.getElementById('algorithmSelect').value;
            const hints = {
                greedy: '貪欲法では、価値/重量比が最も高いアイテムから順に選択します。TSPでは最近傍法を使用します。',
                genetic: '遺伝的アルゴリズムでは、交叉・突然変異により解を進化させます。世代を重ねると解が改善されます。',
                ant_colony: '蟻コロニー最適化では、フェロモンの濃度に基づいて経路を選択します。良い経路ほどフェロモンが濃くなります。',
                dynamic: '動的計画法では、部分問題の最適解を組み合わせて全体の最適解を求めます。',
                manual: 'マウスクリックで都市やアイテムを選択できます。TSPでは都市を順番にクリックして経路を作成してください。'
            };
            
            document.getElementById('hintContent').textContent = hints[algorithm] || '選択されたアルゴリズムのヒントを表示します。';
            document.getElementById('hintPanel').style.display = 'block';
        }

        function hideHint() {
            document.getElementById('hintPanel').style.display = 'none';
        }

        function compareAlgorithms() {
            if (!currentProblem) return;
            
            document.getElementById('comparisonPanel').style.display = 'block';
            const tbody = document.querySelector('#comparisonTable tbody');
            tbody.innerHTML = '';
            
            const algorithms = ['greedy', 'genetic', 'dynamic'];
            const results = [];
            
            algorithms.forEach(alg => {
                let solution, value, time, steps;
                
                // 簡易的な結果計算
                if (alg === 'greedy') {
                    if (problemType === 'knapsack') {
                        const items = currentProblem.items.slice().sort((a, b) => b.ratio - a.ratio);
                        let totalWeight = 0, totalValue = 0;
                        for (const item of items) {
                            if (totalWeight + item.weight <= currentProblem.capacity) {
                                totalWeight += item.weight;
                                totalValue += item.value;
                            }
                        }
                        value = totalValue;
                    } else {
                        value = currentProblem.optimalSolution.distance * 1.2;
                    }
                    time = 0.01;
                    steps = problemSize;
                } else if (alg === 'genetic') {
                    value = problemType === 'knapsack' ? 
                        currentProblem.optimalSolution.totalValue * 0.95 : 
                        currentProblem.optimalSolution.distance * 1.05;
                    time = 2.5;
                    steps = 100;
                } else {
                    value = problemType === 'knapsack' ? 
                        currentProblem.optimalSolution.totalValue : 
                        currentProblem.optimalSolution.distance * 1.1;
                    time = 0.5;
                    steps = problemSize * problemSize;
                }
                
                const optimal = problemType === 'knapsack' ? 
                    currentProblem.optimalSolution.totalValue : 
                    currentProblem.optimalSolution.distance;
                
                const ratio = problemType === 'knapsack' ? 
                    ((value / optimal) * 100).toFixed(1) : 
                    ((optimal / value) * 100).toFixed(1);
                
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${alg.charAt(0).toUpperCase() + alg.slice(1)}</td>
                    <td>${Math.round(value)}</td>
                    <td>${ratio}%</td>
                    <td>${time.toFixed(2)}s</td>
                    <td>${steps}</td>
                `;
            });
        }

        function hideComparison() {
            document.getElementById('comparisonPanel').style.display = 'none';
        }

        function exportData() {
            if (!currentProblem) return;
            
            let data = '';
            if (problemType === 'knapsack') {
                data = 'Weight,Value,Ratio\n';
                currentProblem.items.forEach(item => {
                    data += `${item.weight},${item.value},${item.ratio.toFixed(2)}\n`;
                });
            } else {
                data = 'CityID,X,Y\n';
                currentProblem.cities.forEach((city, index) => {
                    data += `${index},${city.x.toFixed(2)},${city.y.toFixed(2)}\n`;
                });
            }
            
            const blob = new Blob([data], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${problemType}_problem_${Date.now()}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadCustomData() {
            const data = document.getElementById('customData').value.trim();
            if (!data) return;
            
            try {
                const lines = data.split('\n');
                if (problemType === 'knapsack') {
                    const items = lines.map((line, index) => {
                        const [weight, value] = line.split(',').map(Number);
                        return { id: index, weight, value, ratio: value / weight };
                    });
                    currentProblem = { 
                        items, 
                        size: items.length, 
                        capacity: Math.floor(items.length * 10),
                        optimalSolution: { totalValue: items.reduce((sum, item) => sum + item.value, 0) }
                    };
                } else {
                    const cities = lines.map((line, index) => {
                        const [x, y] = line.split(',').map(Number);
                        return { id: index, x: x * width / 100, y: y * height / 100 };
                    });
                    currentProblem = new TSPProblem(cities.length);
                    currentProblem.cities = cities;
                }
                drawProblem();
            } catch (error) {
                alert('データ形式が正しくありません。CSV形式で入力してください。');
            }
        }

        // アニメーションループ
        function animate() {
            updateParticles();
            requestAnimationFrame(animate);
        }

        // イベントリスナー
        window.addEventListener('resize', resizeCanvas);

        // 初期化実行
        init();
        animate();
    </script>
</body>
</html>